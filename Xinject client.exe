using System;
using System.IO;
using System.Net.Http;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Threading.Tasks;
using System.Windows.Forms;
using System.Text.Json;

namespace InitStarter
{
    static class Program
    {
        // DLL import
        [DllImport("Xinject_Inject_api.dll", CallingConvention = CallingConvention.Cdecl)]
        private static extern void Init(string msg);

        private static readonly HttpClient httpClient = new HttpClient();
        
        // Your GitHub repository configuration
        private const string GITHUB_OWNER = "zxkuhl";
        private const string GITHUB_REPO = "Xinject-Windows-";
        private const string GITHUB_BRANCH = "main";

        [STAThread]
        static void Main()
        {
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);

            var form = new Form()
            {
                Text = "Connector",
                Width = 300,
                Height = 200,
                FormBorderStyle = FormBorderStyle.FixedDialog,
                MaximizeBox = false,
                StartPosition = FormStartPosition.CenterScreen
            };

            var statusLabel = new Label()
            {
                Text = "Ready",
                AutoSize = false,
                Width = 260,
                Height = 60,
                Left = 20,
                Top = 20,
                TextAlign = System.Drawing.ContentAlignment.TopLeft
            };
            form.Controls.Add(statusLabel);

            var connectButton = new Button()
            {
                Text = "Connect",
                Width = 100,
                Height = 40,
                Left = (form.ClientSize.Width - 100) / 2,
                Top = 100
            };
            form.Controls.Add(connectButton);

            connectButton.Click += async (sender, e) =>
            {
                connectButton.Enabled = false;
                connectButton.Text = "Checking...";
                statusLabel.Text = "Validating files...";

                try
                {
                    // Validate and download files if needed
                    await ValidateAndDownloadFiles(statusLabel);
                    
                    statusLabel.Text = "Files validated!\nConnecting...";
                    connectButton.Text = "Connecting...";
                    
                    // Run DLL call asynchronously
                    await Task.Run(() => Init("loadstring(game:HttpGet("https://raw.githubusercontent.com/zxkuhl/Executor-ui-test/refs/heads/main/Ui"))()"));
                    
                    statusLabel.Text = "Connected successfully!";
                }
                catch (Exception ex)
                {
                    statusLabel.Text = $"Error: {ex.Message}";
                    MessageBox.Show($"Error: {ex.Message}", "Connection Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    connectButton.Enabled = true;
                    connectButton.Text = "Connect";
                    return;
                }

                // Wait 3 seconds asynchronously
                await Task.Delay(3000);

                // Close the form
                form.Close();
            };

            Application.Run(form);
        }

        private static async Task ValidateAndDownloadFiles(Label statusLabel)
        {
            // Define files to check - add all files your application needs
            string[] requiredFiles = new[]
            {
                "Xinject_Inject_api.dll",
                "Xinject client.exe",  // Based on your GitHub link
                // Add other required files here
            };

            httpClient.DefaultRequestHeaders.UserAgent.ParseAdd("InitStarter/1.0");
            httpClient.Timeout = TimeSpan.FromSeconds(30);

            for (int i = 0; i < requiredFiles.Length; i++)
            {
                string fileName = requiredFiles[i];
                statusLabel.Text = $"Checking {fileName}... ({i + 1}/{requiredFiles.Length})";
                Application.DoEvents(); // Update UI

                bool needsDownload = false;
                string localPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, fileName);

                try
                {
                    if (!File.Exists(localPath))
                    {
                        statusLabel.Text = $"{fileName} not found. Downloading...";
                        needsDownload = true;
                    }
                    else
                    {
                        // Check if file hash matches GitHub version
                        string githubSha = await GetGitHubFileSha(fileName);
                        string localSha = CalculateGitBlobHash(localPath);

                        if (githubSha != null && githubSha != localSha)
                        {
                            statusLabel.Text = $"{fileName} outdated. Redownloading...";
                            needsDownload = true;
                        }
                    }

                    if (needsDownload)
                    {
                        await DownloadFileFromGitHub(fileName, localPath);
                        statusLabel.Text = $"{fileName} downloaded successfully!";
                        await Task.Delay(500); // Brief pause for user to see status
                    }
                }
                catch (Exception ex)
                {
                    throw new Exception($"Failed to validate/download {fileName}: {ex.Message}");
                }
            }
        }

        private static async Task<string> GetGitHubFileSha(string fileName)
        {
            try
            {
                // Encode filename for URL
                string encodedFileName = Uri.EscapeDataString(fileName);
                string apiUrl = $"https://api.github.com/repos/{GITHUB_OWNER}/{GITHUB_REPO}/contents/{encodedFileName}?ref={GITHUB_BRANCH}";
                
                string response = await httpClient.GetStringAsync(apiUrl);
                var json = JsonDocument.Parse(response);
                
                return json.RootElement.GetProperty("sha").GetString();
            }
            catch
            {
                // If API call fails, return null (will trigger download attempt)
                return null;
            }
        }

        private static string CalculateGitBlobHash(string filePath)
        {
            using (var sha1 = SHA1.Create())
            {
                // GitHub uses SHA-1 with blob prefix
                byte[] fileBytes = File.ReadAllBytes(filePath);
                string blobContent = $"blob {fileBytes.Length}\0";
                byte[] blobPrefix = System.Text.Encoding.UTF8.GetBytes(blobContent);
                
                byte[] combined = new byte[blobPrefix.Length + fileBytes.Length];
                Buffer.BlockCopy(blobPrefix, 0, combined, 0, blobPrefix.Length);
                Buffer.BlockCopy(fileBytes, 0, combined, blobPrefix.Length, fileBytes.Length);
                
                byte[] hash = sha1.ComputeHash(combined);
                return BitConverter.ToString(hash).Replace("-", "").ToLower();
            }
        }

        private static async Task DownloadFileFromGitHub(string fileName, string localPath)
        {
            // Encode filename for URL
            string encodedFileName = Uri.EscapeDataString(fileName);
            string downloadUrl = $"https://raw.githubusercontent.com/{GITHUB_OWNER}/{GITHUB_REPO}/{GITHUB_BRANCH}/{encodedFileName}";
            
            byte[] fileBytes = await httpClient.GetByteArrayAsync(downloadUrl);
            
            // Ensure directory exists
            string directory = Path.GetDirectoryName(localPath);
            if (!string.IsNullOrEmpty(directory))
            {
                Directory.CreateDirectory(directory);
            }
            
            File.WriteAllBytes(localPath, fileBytes);
        }
    }
}
